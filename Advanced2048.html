<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>2048 — Improved</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root{
    --bg:#faf8ef;
    --board:#bbada0;
    --tile-light: rgba(238, 228, 218, 0.35);
    --text-dark:#776e65;
    --accent:#8f7a66;
  }
  html,body{height:100%;margin:0;font-family:Arial,Helvetica,sans-serif;background:var(--bg);display:flex;align-items:flex-start;justify-content:center;padding:28px;box-sizing:border-box;}
  #game-wrap{width: max-content; position:relative;}
  #header{display:flex;gap:16px;align-items:center;margin-bottom:12px;}
  h1{margin:0;font-size:22px;color:#776e65}
  .scores{display:flex;gap:8px;align-items:center;}
  .score-box{background:var(--board);color:#fff;padding:8px 12px;border-radius:6px;font-weight:700;min-width:96px;text-align:center;box-sizing:border-box}
  .score-small{font-size:12px;opacity:.9}
  #board{
    background:var(--board);padding:18px;border-radius:10px;display:grid;grid-template-columns:repeat(4,1fr);gap:15px;box-sizing:border-box;
    width: calc(4*100px + 3*15px + 36px); /* keep visual parity with tile sizes */
  }

  .cell {
    width:100px;height:100px;border-radius:6px;background:var(--tile-light);display:flex;align-items:center;justify-content:center;
  }

  .tile {
    position: absolute;
    display:flex;
    align-items:center;
    justify-content:center;
    border-radius:6px;
    font-weight:700;
    transition: transform 140ms ease, top 140ms ease, left 140ms ease;
    box-sizing:border-box;
    will-change: transform, top, left;
    user-select:none;
  }

  /* base visual sizes */
  .tile{width:100px;height:100px;font-size:40px;color:var(--text-dark)}
  .tile.new { animation: pop .18s ease; }
  .tile.merged { animation: pop .18s ease; }

  @keyframes pop {
    0%{ transform: scale(.2) }
    60%{ transform: scale(1.12) }
    100%{ transform: scale(1) }
  }

  /* tile colors (common set) */
  .t-2{ background:#eee4da; color:#776e65; }
  .t-4{ background:#ede0c8; color:#776e65; }
  .t-8{ background:#f2b179; color:#f9f6f2; }
  .t-16{ background:#f59563; color:#f9f6f2; }
  .t-32{ background:#f67c5f; color:#f9f6f2; }
  .t-64{ background:#f65e3b; color:#f9f6f2; }
  .t-128{ background:#edcf72; color:#f9f6f2; font-size:32px; }
  .t-256{ background:#edcc61; color:#f9f6f2; font-size:32px; }
  .t-512{ background:#edc850; color:#f9f6f2; font-size:32px; }
  .t-1024{ background:#edc53f; color:#f9f6f2; font-size:28px; }
  .t-2048{ background:#edc22e; color:#f9f6f2; font-size:28px; }

  /* overlay messages */
  .overlay{
    position:absolute;inset:0;display:flex;align-items:center;justify-content:center;border-radius:10px;background:rgba(238,228,218,0.88);flex-direction:column;color:var(--text-dark);font-weight:700;font-size:28px;z-index:40;
  }
  .overlay button{margin-top:14px;padding:10px 16px;background:var(--accent);color:white;border:none;border-radius:6px;cursor:pointer;font-size:16px}
  .controls{margin-top:10px;display:flex;gap:8px;align-items:center}
  .small {font-size:12px;opacity:.9}

  /* responsiveness */
  @media (max-width:480px){
    #board{width: calc(4*70px + 3*10px + 36px); gap:10px; padding:12px;}
    .cell{width:70px;height:70px;border-radius:6px}
    .tile{width:70px;height:70px;font-size:28px}
    .score-box{min-width:80px;padding:6px 10px}
  }
</style>
</head>
<body>
<div id="game-wrap">
  <div id="header">
    <h1>2048</h1>
    <div class="scores">
      <div id="score" class="score-box"><div class="score-small">Score</div><div id="score-val">0</div></div>
      <div id="best" class="score-box"><div class="score-small">Best</div><div id="best-val">0</div></div>
    </div>
    <div style="margin-left:12px" class="controls small">
      <button onclick="startGame()">Restart</button>
      <button onclick="undoMove()">Undo</button>
    </div>
  </div>

  <div id="board" style="position:relative;">
    <!-- static background cells -->
    <!-- We'll also absolutely-position tiles over the grid for smooth animation -->
    <div id="grid-cells" style="display:grid;grid-template-columns:repeat(4,1fr);gap:15px;pointer-events:none;">
      <!-- cells will be generated by JS -->
    </div>

    <!-- tiles container -->
    <div id="tiles-layer" style="position:absolute;inset:18px;pointer-events:none;"></div>

    <div id="overlay" class="overlay" style="display:none;">
      <div id="overlay-text"></div>
      <div style="display:flex;gap:8px;margin-top:12px">
        <button id="overlay-action">OK</button>
      </div>
    </div>
  </div>
</div>

<script>
/* Improved 2048 Game Script
   Features:
   - Correct single-merge-per-move logic
   - Input disabled on game over (or when overlay open)
   - Swipe threshold for mobile
   - Tile animations: new and merged
   - High score saved in localStorage
   - "You Win" overlay on reaching 2048 (option to continue)
   - Undo (single-step)
*/

const SIZE = 4;
let board = [];
let score = 0;
let best = 0;
let gameActive = true;
let tilesLayer = document.getElementById('tiles-layer');
let gridCells = document.getElementById('grid-cells');
let overlay = document.getElementById('overlay');
let overlayText = document.getElementById('overlay-text');
let overlayAction = document.getElementById('overlay-action');
let scoreValEl = document.getElementById('score-val');
let bestValEl = document.getElementById('best-val');

let prevState = null; // simple undo (store previous board+score)

const CELL_SIZE = () => {
  // used for absolute positioning offsets
  const cell = gridCells.children[0];
  if (!cell) return {w:100,h:100,g:15};
  const rect = cell.getBoundingClientRect();
  const gap = parseInt(getComputedStyle(gridCells).gap) || 15;
  return {w: rect.width, h: rect.height, g: gap};
};

function initGridCells(){
  gridCells.innerHTML = '';
  for(let i=0;i<SIZE*SIZE;i++){
    const div = document.createElement('div');
    div.className = 'cell';
    gridCells.appendChild(div);
  }
}

function saveBest(){
  localStorage.setItem('2048_best', String(best));
}
function loadBest(){
  const b = parseInt(localStorage.getItem('2048_best')||'0',10);
  best = isNaN(b)?0:b;
  bestValEl.innerText = best;
}

// Helpers
function copyBoard(b){
  return b.map(r=>r.slice());
}

function startGame(){
  initGridCells();
  board = Array.from({length:SIZE},()=>Array(SIZE).fill(0));
  score = 0;
  prevState = null;
  gameActive = true;
  updateScore();
  loadBest();
  addRandomTile(true);
  addRandomTile(true);
  render();
  hideOverlay();
}

function updateScore(){
  scoreValEl.innerText = score;
  if(score>best){ best=score; bestValEl.innerText = best; saveBest(); }
}

function addRandomTile(isInit=false){
  const empty=[];
  for(let i=0;i<SIZE;i++) for(let j=0;j<SIZE;j++) if(board[i][j]===0) empty.push({i,j});
  if(empty.length===0) return false;
  const spot = empty[Math.floor(Math.random()*empty.length)];
  board[spot.i][spot.j] = Math.random() < 0.9 ? 2 : 4;
  // store new tile position for animation
  render({newTile: {i:spot.i,j:spot.j}});
  return true;
}

/* Slide logic with correct single merge rule.
   We'll implement a generic function that takes a line (array)
   and slides left (for left/up movements). For right/down we reverse.
*/
function slideAndMergeLine(line){
  // line: array of numbers length <= SIZE
  const newLine = line.filter(v=>v!==0);
  let mergedMarkers = Array(newLine.length).fill(false);
  let i = 0;
  while(i < newLine.length - 1){
    if(newLine[i] === newLine[i+1] && !mergedMarkers[i] && !mergedMarkers[i+1]){
      newLine[i] = newLine[i] * 2;
      score += newLine[i];
      mergedMarkers[i] = true;
      newLine.splice(i+1,1);
      mergedMarkers.splice(i+1,1);
    }
    i++;
  }
  while(newLine.length < SIZE) newLine.push(0);
  return newLine;
}

// Get column
function getCol(j){
  const col = [];
  for(let i=0;i<SIZE;i++) col.push(board[i][j]);
  return col;
}
function setCol(j, col){
  for(let i=0;i<SIZE;i++) board[i][j]=col[i];
}

// Movement functions return true if board changed
function moveLeft(){
  if(!gameActive) return false;
  const before = JSON.stringify(board);
  saveUndo();
  for(let i=0;i<SIZE;i++){
    const newRow = slideAndMergeLine(board[i].slice());
    board[i] = newRow;
  }
  const changed = before !== JSON.stringify(board);
  if(changed) {
    addRandomTile();
    updateScore();
    render({merged:true});
    checkGameState();
  } else {
    render(); // still render to clear any animation classes
  }
  return changed;
}

function moveRight(){
  if(!gameActive) return false;
  const before = JSON.stringify(board);
  saveUndo();
  for(let i=0;i<SIZE;i++){
    const rev = board[i].slice().reverse();
    const slid = slideAndMergeLine(rev);
    board[i] = slid.reverse();
  }
  const changed = before !== JSON.stringify(board);
  if(changed) {
    addRandomTile();
    updateScore();
    render({merged:true});
    checkGameState();
  } else { render(); }
  return changed;
}

function moveUp(){
  if(!gameActive) return false;
  const before = JSON.stringify(board);
  saveUndo();
  for(let j=0;j<SIZE;j++){
    const col = getCol(j);
    const slid = slideAndMergeLine(col);
    setCol(j, slid);
  }
  const changed = before !== JSON.stringify(board);
  if(changed) {
    addRandomTile();
    updateScore();
    render({merged:true});
    checkGameState();
  } else { render(); }
  return changed;
}

function moveDown(){
  if(!gameActive) return false;
  const before = JSON.stringify(board);
  saveUndo();
  for(let j=0;j<SIZE;j++){
    const col = getCol(j).reverse();
    const slid = slideAndMergeLine(col);
    setCol(j, slid.reverse());
  }
  const changed = before !== JSON.stringify(board);
  if(changed) {
    addRandomTile();
    updateScore();
    render({merged:true});
    checkGameState();
  } else { render(); }
  return changed;
}

function hasMoves(){
  for(let i=0;i<SIZE;i++){
    for(let j=0;j<SIZE;j++){
      if(board[i][j] === 0) return true;
      if(i < SIZE-1 && board[i][j] === board[i+1][j]) return true;
      if(j < SIZE-1 && board[i][j] === board[i][j+1]) return true;
    }
  }
  return false;
}

function checkGameState(){
  // Win detection
  for(let i=0;i<SIZE;i++) for(let j=0;j<SIZE;j++){
    if(board[i][j] === 2048){
      showOverlay("You Win!", "Continue", ()=>{ hideOverlay(); gameActive=true; });
      // let player choose to continue — but game remains playable; do not lock.
      return;
    }
  }
  // Game over detection
  if(!hasMoves()){
    gameActive = false;
    showOverlay("Game Over", "Restart", ()=>{ startGame(); });
  }
}

// RENDER: we absolutely-position tiles for animation
function render(options = {}){
  // options: {newTile:{i,j}} or {merged:true}
  tilesLayer.innerHTML = ''; // simple redraw; animations rely on CSS transitions / keyframes

  const cellRect = gridCells.children[0]?.getBoundingClientRect();
  const gap = parseInt(getComputedStyle(gridCells).gap) || 15;
  const boardRect = gridCells.getBoundingClientRect();
  const cellWidth = cellRect ? cellRect.width : 100;
  const cellHeight = cellRect ? cellRect.height : 100;

  for(let i=0;i<SIZE;i++){
    for(let j=0;j<SIZE;j++){
      const val = board[i][j];
      if(val === 0) continue;
      const tile = document.createElement('div');
      tile.className = 'tile t-' + val;
      tile.innerText = val;
      // position
      const top = i * (cellHeight + gap);
      const left = j * (cellWidth + gap);
      tile.style.top = top + 'px';
      tile.style.left = left + 'px';
      // size (for responsive)
      tile.style.width = cellWidth + 'px';
      tile.style.height = cellHeight + 'px';
      // text size based on digits
      tile.style.fontSize = (val >= 1024 ? '24px' : (val >= 128 ? '30px' : '40px'));
      // new / merged animation markers
      if(options.newTile && options.newTile.i === i && options.newTile.j === j){
        tile.classList.add('new');
      }
      if(options.merged){
        // We can't know which specific tile merged after we redraw simply;
        // to give feedback, briefly mark all tiles that are powers >= 4 as merged for a moment when merged option true.
        tile.classList.add('merged');
      }
      tilesLayer.appendChild(tile);
    }
  }

  // remove merged class after animation to avoid persistent scale
  setTimeout(()=> {
    const ms = tilesLayer.querySelectorAll('.merged');
    ms.forEach(x=>x.classList.remove('merged'));
  }, 200);
}

// Simple undo: store previous board+score (one-step)
function saveUndo(){
  prevState = {board: copyBoard(board), score};
}
function undoMove(){
  if(!prevState) return;
  board = copyBoard(prevState.board);
  score = prevState.score;
  prevState = null;
  updateScore();
  render();
  gameActive = true;
  hideOverlay();
}

// Overlays
function showOverlay(text, buttonText, onAction){
  overlayText.innerText = text;
  overlayAction.innerText = buttonText || 'OK';
  overlay.style.display = 'flex';
  overlayAction.onclick = ()=>{
    hideOverlay();
    if(onAction) onAction();
  };
  gameActive = false; // pause input while overlay visible
}
function hideOverlay(){ overlay.style.display = 'none'; gameActive = true; }

// Keyboard & input
document.addEventListener('keydown', (e)=>{
  if(!gameActive) return;
  switch(e.key){
    case 'ArrowLeft': e.preventDefault(); moveLeft(); break;
    case 'ArrowRight': e.preventDefault(); moveRight(); break;
    case 'ArrowUp': e.preventDefault(); moveUp(); break;
    case 'ArrowDown': e.preventDefault(); moveDown(); break;
    case 'z': // simple keyboard undo
      if(e.ctrlKey || e.metaKey) { e.preventDefault(); undoMove(); }
    default: break;
  }
});

// Touch handling: add threshold
let touchStartX = 0, touchStartY = 0;
const SWIPE_THRESHOLD = 40; // px
document.addEventListener('touchstart', (e)=>{
  if(e.touches.length !== 1) return;
  touchStartX = e.touches[0].clientX;
  touchStartY = e.touches[0].clientY;
});
document.addEventListener('touchend', (e)=>{
  if(!gameActive) return;
  const dx = e.changedTouches[0].clientX - touchStartX;
  const dy = e.changedTouches[0].clientY - touchStartY;
  if(Math.abs(dx) < SWIPE_THRESHOLD && Math.abs(dy) < SWIPE_THRESHOLD) return;
  if(Math.abs(dx) > Math.abs(dy)){
    dx > 0 ? moveRight() : moveLeft();
  } else {
    dy > 0 ? moveDown() : moveUp();
  }
});

// On-screen arrow buttons could be added; not necessary here.

// init
loadBest();
startGame();
</script>
</body>
</html>
